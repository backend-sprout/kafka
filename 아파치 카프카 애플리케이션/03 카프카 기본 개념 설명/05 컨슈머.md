# 컨슈머 
프로듀서가 전송한 데이터는 카프카 브로커에 적재된다.     
컨슈머는 적재된 데이터를 사용하기 위해 브로커로부터 데이터를 가져와서 필요한 처리를 한다.    
(토픽으로부터 데이터를 가져와서 문자 발송 처리를 한다.)     
  

## 컨슈머 중요 개념 

토픽의 파티션으로부터 데이터를 가져가기 위해 컨슈머를 운영하는 방법은 크게 2가지이다.  

* 1개 이상의 컨슈머로 이루어진 컨슈머 그룹을 운영한다.     
* 토픽의 특정 파티션만 구독하는 컨슈머를 운영한다.    

## 컨슈머 그룹  

컨슈머를 각 커뉴머 그룹으로부터 격리된 환경에서 안전하게 운영될 수 있도록 해주는 방식          
컨슈머 그룹으로 묶인 컨슈머들은 토픽의 1개 이상 파티션들에 할당되어 데이터를 가져갈 수 있다.      

컨슈머 그룹으로 묶인 컨슈머가 토픽을 구독해서 데이터를 가져갈 때,   
1개의 파티션은 최대 1개의 컨슈머에 할당 가능하고 1개 컨슈머는 여러 개의 파티션에 할당 될 수 있다.    
실은 여러 컨슈머를 둘 수 있지만, 성능상 이점이 아니라 저하(불필요한 스레드 낭비)를 일으키기 때문에 지양한다.    
이러한 특징으로 컨슈머 그룹의 컨슈머 개수는 가져가고자 하는 토픽의 파티션 개수보다 같거나 작아야한다.   

컨슈머 그룹은 다른 컨슈머 그룹과 격리되는 특징을 가지고 있다.   
따라서 카프카 프로듀서가 보낸 데이터를 각기 다른 역할을 하는 컨슈머 그룹끼리 영향을 받지 않게 처리할 수 있다.  

데이터파이프라인을 구축한다고 가정한다.   

1. 리소스 수집
2. 엘라스틱에 저장(시간순으로 확인하기 위해)  
3. 하둡에 저장(대용량 적재를 위해)    

만약, 카프카가 아니라면 서버에서 실행되는 리소스 수집 및 전송 에이전트는         
수집한 리소스를 엘라스턱 서치와 하둡에 적재하기 위해 동기적으로 적재를 요청할 것이다.        
이렇게 동기로 실행되는 에이전트는 엘라스틱서치 또는 하둡 둘중 하나에 장애가 발생한다면 더는 적재가 불가능할 수 있다.    

카프카는 이러한 파이프라인을 운영함에 있어 최종 적재되는 저장소의 장애에 유연하게 대응할 수 있도록     
각기 다른 저장소에 저장하는 컨슈머를 다른 컨슈머 그룹으로 묶음으로써 각 저장소의 장애에 격리되어 운영할 수 있다.    
장애가 발생하더라도 다른 그룹에 영향을 주지 않고 장애를 복구하면     
오프셋 개념을 통해 적재 완료한 데이터 이후의 데이터부터 다시 읽는다.   

이렇게 데이터 파이프로안을 운영함에 있어 적절히 컨슈머 그룹을 분리하여 운영하는 것은 매우 중요하다.  
만약, 동일 컨슈머 그룹으로 작업을 했다면 이전 동기 문제가 동일하게 발생할 수 있다.     
현재 운영하고 있는 토픽의 데이터가 어디에 적재되는지, 어떻게 처리되는지 파악하고     
컨슈머 그룹으로 따로 나눌 수 있는 것은 최대한 나누는 것이 좋다.  

## 리밸런싱 

컨슈머 그룹의 컨슈머에 장애가 발생하면 장애가 발생하지 않은 동일 컨슈머 그룹의 다른 컨슈머에 소유권이 넘어간다.       
이러한 과정을 리밸런싱이라고 부르고, 크게 2가지 상황에서 발생한다.   

* 컨슈머가 추가되는 상황   
* 컨슈머가 제외되는 상황   

컨슈머에 이슈가 발생하면 매핑된 파티션은 더는 데이터를 처리하지 못하고 있으므로 데이터 처리에 지연이 발생할 수 있다.     
리밸런싱은 **이슈가 발생한 컨슈머를 컨슈머 그룹에서 제외하여 모든 파티션이 지속적으로 데이터를 처리할 수 있도록 가용성을 높여준다.**          
그리고 매핑되었던 파티션을 다른 컨슈머와 매핑시켜주는 작업을 진행한다.      
  
리밸런싱은 컨슈머가 데이터를 처리하는 도중에 언제든지 발생할 수 있으므로,     
데이터 처리 중 발생한 리밸런싱에 대응하는 코드를 작성해야한다.      

리밸런싱은 유용하지만 자주 발생하면 안된다.   
리밸런싱이 발생할 때 파티션의 소유권을 컨슈머로 재할당하는 과정에서   
해당 컨슈머 그룹의 컨슈머들이 토픽의 데이터를 읽을 수 없기 때문이다. (모든 스레드가 멈춘다.)  

그룹 조정자는 리밸런싱을 발동시키는 역할을 하는데 컨슈머 그룹의 컨슈머가 추가되고 제거될 때를 감지한다.  
카프카 브로커 중 한대가 그룹 조정자 역할을 수행한다.   

## 커밋과 오프셋 
  
컨슈머는 카프카 브로커로부터 데이터를 어디까지 가져갔는지 **커밋을 통해 기록한다.**       
특정 토픽의 파티션을 어떤 컨슈머 그룹이 몇 번째 가져갔는지     
카프카 브로커내부에서 사용되는 내부 토픽`(__consumer_offsetes)`에 기록된다.       

컨슈머 동작 이슈가 발생하여 `(__consumer_offsetes)`토픽에 어느 레코드까지 읽어갔는지 오프셋 커밋이 기록되지 못했다면   
데이터 처리의 중복이 발생할 수 있다.   
그러므로 데이터 처리의 중복이 발생하지 않게 하기 위해서는 컨슈머 애플리케이션이 오프셋 커밋을 정삭저으로 처리했는지 **검증해야한다.**     









컨슈머는 Polling을 통해 데이터를 받아온다.  
