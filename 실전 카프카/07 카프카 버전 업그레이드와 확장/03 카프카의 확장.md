# 카프카의 확장  

초기 카프카 환경을 구성할 때, 트래픽과 메시지량을 고려하여 규모를 산정하지만 이를 정확히 예측하기는 어렵다.   
그러므로 트래픽과 사용량이 증가된다면 이에따라 확장도 고려해야한다.   
카프카는 이렇게 폭발적으로 사용량이 증가하는 경우를 고려해 안전하고 손쉽게 확장할 수 있도록 디자인되었다.   

이번에는 카프카의 사용량이 폭발적으로 증가해서 카프카를 확장하는 경우를 실습해보자.   

## 테스트 토픽 생성 
```shell
/usr/local/kafka/bin/kafka-topics.sh    
--bootstrap-server peter-kafka01.foo.bar:9092 
--create 
--topic peter-scaleout1
--partitions 4 
--replication-factor 1

> Created topic peter-scaleout1
```
생성된 토픽을 파악하기 위해서 토픽 상세보기를 진행하자 

```shell
/usr/local/kafka/bin/kafka-topics.sh     
--bootstrap-server peter-kafka01.foo.bar:9092
--describe
--topic peter-scaleout1
``` 

[#](#)  

출력된 내용을 그림으로 표현하면 위와 같다.   
카프카의 확장 실습을 위해 브로커를 하나 더 추가할 것이고 주키퍼 서버중 하나인 zk03을 이용하려고한다.     
책에서 알려주는 명령어를 입력해서 카프카를 설치했다면 설정 파일을 편집하자.  

```shell
sudo vi /usr/local/kafka/config/server.properties 
```
`/usr/local/kafka/config/server.properties` 설정 파일에서   
`broker.id=4`가 잘 지정되었는지 확인한다.     
`broker.id=4`로 설정하는 이유는 현재 브로커들이 1,2,3 으로 설정되어있기 때문이다.(고유해야함)   

이제 다음과 같이 systemctl 명령어를 이용해 카프카가 실행중인 상태인지 확인한다.(running 확인)     
```shell 
sudo systemctl status kafka-server 
``` 
 
브로커를 추가한 다음, 기존의 토픽과 파티션은 어떻게 될까?         
카프카는 확장을 위해 브로커를 한대 추가한 상태이다.       
**카프카의 부하가 높은 상황이라 긴급하게 브로커를 한대 추가했지만, 기존의 토픽과 파티션들은 변화가 없다.**     
즉, **브로커 추가 작업은 간단히 끝나지만 토픽과 파티션들은 새로 추가된 브로커로 이동하지 않는다.**      
**관리자가 수작업으로 토픽의 파티션들을 고루 분산시켜줘야한다.**     
         
브로커를 추가한 후 토픽을 생성했을 때 브로커별로 잘 분산되는지 확인해보자.   

```shell
/usr/local/kafka/bin/kafka-topic.sh   
--bootstrap-server peter-kafka01.foo.bar:9092.   
--create   
--topic peter-caleout2  
--partitions 4
--replication-factor 1

> Created topic peter-scaleout2 
```    

토픽 생성이 완료되면 다음과 같이 토픽 상세보기를 통해 파티션들이 어느 브로커에 위치하고 있는지를 확인한다.   

```bash
/usr/local/kafka/bin/kafka-topics.sh   
--bootstra-server peter-kafka01.foo.bar:9092   
--describe 
--topic peter-scaleout2

> 토픽에 대한 정보가 나온다.   
```  

토픽은 생성했을때의 설정값 그대로    
파티션이 4개로 새롭게 확장한 브로커 4번을 포함해 브로커 ID당 하나의씩 고르게 분포되어있음을 알 수 있다.  
브로커 4번을 추가하기 전에, 생성한 토픽 peter-scaleout1과 peter-scaleout2 토픽을 살펴보자.    

[#](#)    
  
위 그림과 같이  
브로커 4번을 추가하기 전에 생성한 토픽 peter-scaleout1 은 그대로 유지되고 있다.     
브로커 4번을 추가한 후에 생성한 토픽 peter-scaleout2 는 고르게 유지되고 있다.    

이러한 현상은 브로커의 리소스 측면에서 다소 비효율적일 수 있다.   
   
카프카 클러스터의 부하가 전체적으로 높은 상태이며  
특히 peter-kafka03 브로커의 부하가 가장 높은 상황이라 가정하자   
관리자가 브로커들의 부하를 분산시키기 위한 목적으로 브로커를 추가해도 기존 파티션은 그대로 남아있다.  
즉, 부하는 계속 높은 상황이 이어질 것이며 문제가 해결되지는 않을 것이다.   

## 브로커의 부하 분산 
 
전체 브로커들에게 토픽의 파티션을 고르게 부하 분산하기 위해서는      
새로 추가된 브로커를 비롯해 모든 브로커에게 균등하게 파티션을 분산시켜야한다.    
카프카에서 제공하는 `kafka-reassign-partitions.sh`라는 도구를 이용하면 파티션을 이동시킬 수 있다.    
이 도구를 이용해 실습용 토픽의 파티션을 분산시키자.   
     
우선, 분산 작업이 어떤 순서로 이루어지는지를 살펴보자.  
1. **분산시킬 대상 토픽을 정한다.
2. **토픽의 파티션들을 어느 브로커로 분산시킬지를 정한다.**    
3. 파티션 이동 작업을 위해 정해진 JSON 포맷으로 파일을 생성한다.  
 
**resassign-partitions-topic.json**.  
```json
{
    "topics" : 
        [{"topic" : "peter-scaleout1"}, {"topic" : "peter-scaleout2"}],
        "version" : 1
}
```
peter-scaleout1, peter-scaleout2 토픽을 추가한 JSON 파일이다.       
작업 대상을 `topics` 안에 넣으면 된다.  

```shell 
/usr/local/kafka/bin/kafka-reassign-partitions.sh
--bootstrap-server peter-kafka01.foo.bar:9092
--generate
--topics-to-move-json-file reassign-partitions-topic.json. 
--broker-list "1,2,3,4"

> 실행결과 
```  
분산시킬 대상 토픽에 대한 JSON 파일이 생성되었다면,   
`kafka-reassign-partitions.sh` 명령어를 이용해 파티션을 분산시킬 브로커 리스트를 지정한다.      
여기서는 1,2,3,4 브로커 모두를 지정했다.   

실행한 결과를 살펴보면,   
peter-scalueout1 토픽의 현재 설정된 파티션 배치를 가장 먼저 보여주고 이후 제안하는 파티션 배치가 출력되었다.    
이제 제안된 파티션 배치 설정을 복사한 후 새로운 move.js 파일을 생성한다.  

```json 
~~~
```   
  
kafka-reassign-partitions.sh 도구를 이용해     
peter-scaleout1 토픽의 제안된 파티션 배치의 내용을 복사한 예제이다.      
위 내용과 동일하게, move.json 파일을 생성했다면 이제 peter-scaleout1 토픽에 대해서 파티션 배치를 실행하자.    
이제 kafka-reassign-partitions.sh 명령어와 --reassignment-json-file 옵션으로     
move.json 을 정의해 peter-scaleout 토픽에 대해 파티션 배치를 실행하자.   

```shell

```




'




