# 중복 없는 전송 
   
**데이터 프로세싱 과정에서 메시지가 중복되지 않고 처리된다면**                
데이터 처리 업무를 담당하는 데이터 엔지니어나 개발자에게 매우 유용할 것이다.       
왜냐하먄 언제 발생할지 모르는 메시지 중복으로 인해 데이터 프로세싱 과정에서       
**모든 메시지에 대해 중복 처리 과정을 따로 거치지 않아도 되며 별도로 데이터 정합성을 체크할 필요도 없기 때문이다.**       
 
일부 서비스는 메시지 중복을 허용하는 경우도 있지만,     
특정 서비스에서 메시지가 중복처리된다면 치명적인 상황이 발생할 수 있다.(결제 등)  
    
이에 따라 카프카는 사용자들의 개발 편의를 높이기 위해 중복 없이 전송할 수 있는 기능을 제공한다.       
'중복 없는 전송'이라면 얼핏 간단해보이지만, 이 기능을 실제 구현하는 개발자 입장에서는 상당히 어려운 작업이다.   
이를 알기 위해서 메시지 시스템들의 메시지 전송을 살펴보자. 

```
멱등성이란 동일한 작업을 여러번 수행하더라도 결과가 달라지지 않는 것을 의미한다.   
본래 멱등법칙은 수학이나 전산학에서 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질을 의미한다.  
이와 동일한 개념으로 카프카에서도 사용자가 프로듀서를 이용해 메시지를 수차례 중복 전송하더라도    
카프카에는 중복 없이 한번만 저장된다.    
   
배포 도구로 사용하는 앤서블도 멱등성을 제공하지만,       
앤서블을 작성하는 개발자에 따라 멱등성이 깨지는 경우가 있으니 주의해야한다.    
멱등성과 관련한 좀 더 자세한 정보는 다음 위키피디어 정보를 참고하자.   
```

메시지 시스템들의 메시지 전송 방식에는 `적어도 한번 전송`, `최대 한 번 전송`, `정확히 한 번 전송`이 있으며,    
지금부터 `적어도 한 번 전송`과 `최대 한번 전송 방식`은 서로 어떠한 차이가 있는지를 살펴보고,       
카프카 프로듀서에 적용된 `중복 없는 전송` 과정도 알아보자.        

## 적어도 한번 전송 

[#](#). 
  
위 그림은 `적어도 한 번 전송` 과정을 나타낸 그림이다.        
`적어도 한 번 전송` 과정에서 발생할 수 있는 예상 시나리오를 가정하여 순차적으로 살펴보자.     
    
1. 프로듀서가 브로커의 특정 토픽으로 메시지A를 전송한다       
2. 브로커는 메시지A를 기록하고, 잘 받았다는 ACK를 프로듀서에게 응답한다.        
3. 브로커의 ACK를 받은 프로듀서는 다음 메시지인 메시지B를 브로커에게 전송한다.         
4. 브로커는 메시지B를 기록하고, 잘 받았다는 ACK를 프로듀서에게 전송하려한다.     
   하지만 네트워크 오류 또는 브로커 장애가 발생하여       
   결국 프로듀서는 메시지B에 대한 ACK를 받지 못한다.    
5. 메시지B를 전송한 후 브로커로부터 ACK를 받지 못한 프로듀서는     
   브로커가 메시지를 받지 못했다고 판단해 메시지B를 재전송한다.  
 
위 과정에 대해서 설명하자면       
프로듀서는 메시지를 저장하고 ACK를 보내지 못한건지,      
메시지도 저장 못하고 ACK를 보내지 못한건지 알 수가 없다.     
그렇기에 프로듀서는 메시지를 한번 더 보내는데, 결국 중복 저장되는 문제가 생긴다.    

이렇게 네트워크의 회선 장애나 기타 장애 상황에 따라 일부 메시지 중복이 발생할 수 있지만,   
`최소한 하나의 메시지`는 반드시 보장한다는 것이 `적어도 한 번 전송` 방식이며,    
**카프카는 `기본`적으로 이와 같은 `적어도 한 번 전송` 방식을 기반으로 동작한다.**      

## 최대한 한번 전송    

[#](#)   

위 그림은 `최대한 한번 전송`을 나타냈다.    
  
1. 프로듀서가 브로커의 특정 토픽으로 메시지A를 전송한다.   
2. 브로커는 메시지A를 기록하고, 잘 받았다는 ACK를 프로듀서에게 응답한다.     
3. 프로듀서는 다음 메시지인 B를 브로커에게 전송한다.    
4. **브로커는 메시지B를 기록하지 못하고, 잘 받았다는 ACK를 프로듀서에게 전송하지 못한다.**    
5. **프로듀서는 브로커가 메시지B를 받았다고 가정하고, 메시지 C를 전송한다.**    
  
`최대 한번 전송`은 ACK를 받지 못하더라도 재전송을 하지 않는 방식이다.    
사실 최대 한번 전송에서 ACK를 응답하는 과정은 없어도 되지만.      
`적어도 한 번 전송`과의 비교를 위해 추가한 것이다.   

`최대 한번 전송 과정`에서 프로듀서는 메시지의 중복 가능성을 회피하기 위해 재전송을 하지 않는다.    
다시 말해, 일부 메시지의 손실을 감안하더라도 중복 전송은 하지 않는 경우다.        

`최대 한번 전송 과정`을 이용하는 곳이 있을까 생각이 들수도 있지만   
일부 메시지가 손실되더라도 높은 처리량을 필요로하는 대량의 로그 수집이나 IoT 같은 환경에서 사용하곤 한다.    

## 중복 없는 전송  
중복 없는 전송은 카프카의 0.11 버전에서 추가된 기능이다.   

[#](#) 

위 그림은 중복 없는 전송 과정을 나타내고 있다.    
이전 그림들과 다르게 메시지 하단에 숫자가 추가되었다.    

1. 프로듀서가 브로커의 특정 토픽으로 메시지A를 전송한다.      
   이 때, PID 0과 메시지 번호0을 헤더에 함께 전송한다.     
2. 브로커는 메시지A를 저장하고, PID와 메시지 번호 0을 메모리에 기록한다.    
   그리고 메시지를 잘 받았다는 ACK를 프로듀서에게 응답한다.       
3. 프로듀서는 다음 메시지인 메시지B를 브로커에게 전송한다.    
   PID는 동일하게 0이고, 메시지 번호는 1이 증가하여 1이된다.  
4. 브로커는 메시지B를 저장하고, PID와 메시지 번호1을 메모리에 기록한다.  
   그리고 메시지를 잘 받았다는 ACK를 프로듀서에게 전송하려고 한다.     
   하지만 네트워크 오류 또는 브로커 장애가 발생하여 프로듀서는 메시지B에 대한 ACK를 받지 못한다.         
5. 브로커로부터 ACK를 받지 못한 프로듀서는 브로커가 메시지B를 받지 못했다고 판단해 메시지B를 재전송한다.  

위 과정은 `적어도 한번 전송`과 동일하다.     
하지만, `프로듀서가 메시지B를 다시 전송 후 브로커의 동작`에 차이가 있다.        
**브로커는 프로듀서가 보낸 메시지의 헤더에서 PID와 메시지 번호를 비교해서 저장 여부를 판단한다.**         
이미 저장되어있다면 저장하지 않고, 저장되어 있지 않다면 저장을 한 후 ACK를 내려다 보내준다.   

### PID와 메시지 번호  
> PID와 메시지 번호에 대해서 설명하고자한다.  
  
프로듀서는 고유한 PID를 할당 받게 되고     
**PID와 메시지에 대한 번호를 메시지의 헤더에 포함해 메시지를 전송한다.**  
참고로, 메시지 번호를 시퀀스 번호라고도 한다.   
    
브로커에서는 각 메시지마다 PID값과 시퀀스 번호를 메모리에 유지하게 되며,       
이 정보를 이용해 브로커에 기록된 메시지들의 중복 여부를 알 수 있다.          
즉, 프로듀서가 중복된 메시지를 보내도 브로커에는 메시지가 중복 저장되지 않는다.    
   
PID는 사용자가 별도로 생성하는 것이 아니며 프로듀서에 의해 자동 생성된다.       
PID는 프로듀서와 카프카 사이에서 내부적으로만 이용되므로 사용자에게 따로 노출되지 않는다.     

또한, 메시지마다 부여되는 시퀀스 번호는 0부터 시작해 순차적으로 증가한다.    
프로듀서에서 시퀀스 번호를 메시지마다 순차적으로 증가시키는 방법과 동일하게    
**브로커에서도 기록되는 메시지들에 대해 시퀀스 번호를 증가시킨다.**   
   
따라서 프로듀서가 보낸 메시지의 시퀀스 번호가       
**브로커가 갖고 있는 시퀀스 번호보다 정확하게 하나 큰 경우가 아니라면,**      
**브로커는 프로듀서의 메시지를 저장하지 않는다.**      
바로 이 동작 때문에 메시지 중복을 피할 수 있는 것이다.       
  
이렇게 메시지 중복을 피하기 위해 사용되는 PID와 시퀀스 번호 정보는     
브로커의 메모리에 유지되고, 리플리케이션 로그에도 저장된다.       
따라서 예기치 못한 브로커의 장애 등으로 리더가 변경되는 일이 발생하더라도     
새로운 리더가 PID와 시퀀스 번호를 정확히 알 수 있으므로 중복 없는 메시지 전송이 가능하다.     
 
중복없는 전송 방식은 매우 유용해보이지만,      
**사실 결국 중복을 피하기 위해 메시지 비교 동작에는 오버헤드가 존재할 수 밖에 없다.**       
하지만, 카프카에서는 메시지 비교 동작으로 발생하는 오베헤드를 최소화하기 위해 고민했으며   
**메시지에 단순한 숫자 필드만 추가하는 방법으로 구현했기에, 이러한 오버헤드가 생각보다 높은 편은 아니다.**    

컨플루언트에 따르면, 중복 없는 전송을 적용한 후 기존 대비 최대 20%정도만 성능이 감소했다고 한다.    
따라서 프로듀서 전송 성능에 그다지 민감하지 않은 상황에서 중복 없는 메시지 전송이 필요하다면   
이 방식을 설정 적용하는 것을 권장한다.     

중복 없는 전송을 위해서는 다음과 같이 프로듀서의 일부 설정들을 변경해야한다.    

|프로듀서 옵션|값|설명|
|---------|--|--|
|enable.idemtoence|true|프로듀서가 중복없는 전송을 허용할지 결정하는 옵션이다.<br>기본값은 false 이므로,<br>이 옵션을 설정하기 원한다면 true로 변경해야한다.<br>true변경시 다음에 나오는 옵션 들도 반드시 변경해야한다.<br>그렇지 않으면 ConfigException이 발생한다.|    
|max.in.flight.requests.per.connection|1 ~ 5|ACK를 받지 않은 상태에서 하나의 커넥션에서 보낼 수 있는 최대 요청 수이다.<br>기본값은 5이며, 5이하로 설정해야한다.|    
|acks|all|프로듀서 acks와 관련된 옵션으로서, 기본값은 1이며 all로 설정해야한다.|       
|retries|5|ACK를 받지 못한 경우 재시도를 해야 하므로, 0보다 큰 값으로 설정해야한다.|     
