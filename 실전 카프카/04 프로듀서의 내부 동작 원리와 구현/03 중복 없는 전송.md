# 중복 없는 전송 
   
**데이터 프로세싱 과정에서 메시지가 중복되지 않고 처리된다면**                
데이터 처리 업무를 담당하는 데이터 엔지니어나 개발자에게 매우 유용할 것이다.       
왜냐하먄 언제 발생할지 모르는 메시지 중복으로 인해 데이터 프로세싱 과정에서       
**모든 메시지에 대해 중복 처리 과정을 따로 거치지 않아도 되며 별도로 데이터 정합성을 체크할 필요도 없기 때문이다.**       
 
일부 서비스는 메시지 중복을 허용하는 경우도 있지만,     
특정 서비스에서 메시지가 중복처리된다면 치명적인 상황이 발생할 수 있다.(결제 등)  
    
이에 따라 카프카는 사용자들의 개발 편의를 높이기 위해 중복 없이 전송할 수 있는 기능을 제공한다.       
'중복 없는 전송'이라면 얼핏 간단해보이지만, 이 기능을 실제 구현하는 개발자 입장에서는 상당히 어려운 작업이다.   
이를 알기 위해서 메시지 시스템들의 메시지 전송을 살펴보자. 

```
멱등성이란 동일한 작업을 여러번 수행하더라도 결과가 달라지지 않는 것을 의미한다.   
본래 멱등법칙은 수학이나 전산학에서 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질을 의미한다.  
이와 동일한 개념으로 카프카에서도 사용자가 프로듀서를 이용해 메시지를 수차례 중복 전송하더라도    
카프카에는 중복 없이 한번만 저장된다.    
   
배포 도구로 사용하는 앤서블도 멱등성을 제공하지만,       
앤서블을 작성하는 개발자에 따라 멱등성이 깨지는 경우가 있으니 주의해야한다.    
멱등성과 관련한 좀 더 자세한 정보는 다음 위키피디어 정보를 참고하자.   
```

메시지 시스템들의 메시지 전송 방식에는 `적어도 한번 전송`, `최대 한 번 전송`, `정확히 한 번 전송`이 있으며,    
지금부터 `적어도 한 번 전송`과 `최대 한번 전송 방식`은 서로 어떠한 차이가 있는지를 살펴보고,       
카프카 프로듀서에 적용된 `중복 없는 전송` 과정도 알아보자.        

[#](#). 
  
위 그림은 `적어도 한 번 전송` 과정을 나타낸 그림이다.        
`적어도 한 번 전송` 과정에서 발생할 수 있는 예상 시나리오를 가정하여 순차적으로 살펴보자.     
    
1. 프로듀서가 브로커의 특정 토픽으로 메시지A를 전송한다       
2. 브로커는 메시지A를 기록하고, 잘 받았다는 ACK를 프로듀서에게 응답한다.        
3. 브로커의 ACK를 받은 프로듀서는 다음 메시지인 메시지B를 브로커에게 전송한다.         
4. 브로커는 메시지B를 기록하고, 잘 받았다는 ACK를 프로듀서에게 전송하려한다.     
   하지만 네트워크 오류 또는 브로커 장애가 발생하여       
   결국 프로듀서는 메시지B에 대한 ACK를 받지 못한다.    
5. 메시지B를 전송한 후 브로커로부터 ACK를 받지 못한 프로듀서는     
   브로커가 메시지를 받지 못했다고 판단해 메시지B를 재전송한다.  
 
위 과정에 대해서 설명하자면       
프로듀서는 메시지를 저장하고 ACK를 보내지 못한건지,      
메시지도 저장 못하고 ACK를 보내지 못한건지 알 수가 없다.     
그렇기에 프로듀서는 메시지를 한번 더 보내는데, 결국 중복 저장되는 문제가 생긴다.    

이렇게 네트워크의 회선 장애나 기타 장애 상황에 따라 일부 메시지 중복이 발생할 수 있지만,   
`최소한 하나의 메시지`는 반드시 보장한다는 것이 `적어도 한 번 전송` 방식이며,    
**카프카는 `기본`적으로 이와 같은 `적어도 한 번 전송` 방식을 기반으로 동작한다.**      







