# 04 정확히 한 번 전송 
       
데이터 처리나 가공 작업을 하는 대부분의 사람들은          
데이터 파이프라인에서 메시지 중복이나 손실이 발생하지 않기를 원한다.        
가장 이상적인 상황이라면 모든 메시지를 정확히 한번 처리해주기를 원한다.(은행)   
 
만약 메시지를 처리하는 애플리케이션에서     
`중복 없는 전송` 또는 `정확히 한 번 처리`하는 기능을 제공한다면, 이는 매우 반가운 일이다.     
많은 애플리케이션이 `정확히 한번 처리` 기능을 제공한다고는 하지만, 이를 구현하는 것은 굉장히 어려운 일이다.       
또 메세지를 처리하다 보면 예상하기 힘든 다양한 변수들이 발생할 수 있어서 여러 조건들이 붙기도 한다.    
 
앞서 카프카에서는 **멱등성 옵션을 이용해 중복없는 전송을 할 수 없다고 설명했다.**          
**하지만, 이 중복없는 전송 방식이 정확히 한 번 전송한다는 의미는 아니다.**         
**카프카에서 장확히 한번 전송은 트랜잭션과 같은 전체적인 프로세스 처리를 의미하며,**       
**중복없는 전송은 정확히 한 번 전송의 일부 기능이라 할 수 있다.**  
   
전체적인 프로세스를 관리하기 위해 카프카에서는      
정확히 한번 처리를 담당하는 별도의 프로세스가 있는데 **이를 트랜잭션 API라고 부른다.**       
그럼 카프카에서 정확히 한번 전송 방식이 어떻게 구현되는지 살펴보자.    

```
트랜잭션이란 데이터베이스와 같은 시스템에서 이루어지는 논리적인 작업 단위를 말한다.       
작업이 완전히 실행되지 않거나 중간에 작업이 실패하는 경우,    
전체 작업을 실패로 처리하여 데이터베이스의 데이터 무결성을 지켜준다.        
트랜잭션은 ACID 4가지 성질을 가진다.    
```  

## 디자인   
   
프로듀서가 카프카로 **정확히 한 번 방식**으로 메시지를 전송할 때,        
**프로듀서가 보내는 메시지들은 원자적으로 처리되어 전송에 성공하거나 실패하게 된다.**   

이런 프로듀서의 전송을 위해 카프카에는     
컨슈머 그룹 코디네이터와 동일한 개념으로        
**트랜잭션 코디네이터**라는 것이 서버측에 존재한다.     

트랜잭션 코디네이터의 역할을 **프로듀서에 의해 전송된 메시지를 관리하는 커밋 또는 중단 등을 표시한다.**    
카프카에서는 컨슈머 오프셋 관리를 위해 오프셋 정보를 카프카의 내부 토픽에 저장하는데,     
트랜잭션도 동일하게 **트랜잭션 로그를 카프카의 내부 토픽인 `__transactio_state`에 저장한다.**        
`__transactio_state`는 카프카의 내부 토픽이지만,    
이 역시 토픽이므로 파티션 수와 리플리케이션 팩터 수가 존재하며 **브로커의 설정을 통해 관리자가 설정할 수 있다.**       

**__transactio_state 설정값**   
  
* transaction.state.log.num.partition=50
* transaction.state.log.replication.factor=3

이 때, **프로듀서가 해당 토픽에 트랜잭션 로그를 직접 기록하는 것이 아님을 참고하자.**   
프로듀서는 트랜잭션과 관련 정보를 트랜잭션 코디네이터에 알리고,     
**모든 정보의 로그는 트랜잭션 코디네이터가 직접 기록한다.**      
    
정확히 한 번 전송을 이용해 전송된 메시지들이 카프카에 저장되면,     
카프카의 메시지를 다루는 `클라이언트들`은 **해당 메시지들이 정상적으로 커밋된 것인지 또는 실패한 것인지 식별할 수 있어야한다.**      
카프카에서는 이를 식별하기 위한 정보로서, **`컨트롤 메시지`라고 불리는 특별한 타입의 메시지가 추가로 사용된다.**     
 
컨트롤러 메시지는   
**페이로드에 애플리케이션 데이터(메시지의 벨류)를 포함하지 않으며**    
**애플리케이션들에게 노출되지도 않는다.**          
컨트롤러 메시지는 오직 브로커와 클라이언트 통신에서만 사용된다.     

## 프로듀서 예제 코드  

```java
```

1. 정확히 한번 전송을 위한 설정 
2. 프로듀서 트랜잭션 초기화 
3. 프로듀서 트랜잭션 시작 
4. 프로듀서 트랜잭션 중단 
5. 프로듀서 트랜잭션 커밋 

중복없는 전송 방식의 실습은 콘솔 프로듀서와 설정 파일을 이용해 진행했는데,      
여기에서는 트랜잭션 처리를 위한 예제 코드와 단계별 동작을 설명하기 위해        
자바 프로그래밍 언어를 이용한 실습을 진행하고, 필수 설정들 역시 코드내에 포함했다.   
     
`중복 없는 전송`과 `정확히 한번 전송`의 옵션 설정에서      
가장 큰 차이점이자 주의해야할 설정은 `TRANSATION_ID_CONFIG`이다.      
프로듀서의 `TRANSATION_ID_CONFIG` 옵션은 **실행하는 프로듀서 프로세스마다 고유한 아이디로 설정해야 한다.**   
예를들어, 2개의 프로듀서가 있다면 두 프로듀서마다 다른 아이디로 설정해야한다.  

## 단계별 동작    

[#](#)  

`정확히 한번 전송`을 위해서는 트랜재션 API를 사용한다고 말을 했다.      
따라서 **가장 먼저 수행하는 작업은 트랜잭션 코디네이터 찾기이다.**         
      
프로듀서는 브로커에게 `FindCoordinator Request` 를 보내서 트랜잭션 코디네이터의 위치를 찾는다.          
컨슈머 코디네이터와 유사한 역할을 하는 **트랜잭션 코디네이터는 브로커에 위치한다.**      
트랜잭션 코디네이터의 주 역할을 `PID`와 `transactional.id`를 매핑하고 해당 트랜잭션 전체를 관리하는 것이다.      
만약 트랜잭션 코디네이터가 존재하지 않는다면, 신규 트랜잭션 코디네이터가 생성된다.    
 
`__transaction_state` 토픽의 파티션 번호는 `transaction.id`를 기반으로 해시하여 결정되고,      
이 파티션의 리더가 있는 브로커가 트랜잭션 코디네이터의 브로커로 최종 선정된다.      
이는 transaction.id가 정확히 하나의 코디네이터만 갖고 있다는 의미와도 같습니다.      

[#](#)   
  
다음으로 프로듀서 초기화 동작이다.     
프로듀서는 `initTransactions()` 메서드를 통해     
트랜잭션 전송을 위한 `InitPidRequest` 를 트랜잭션 코디네이터로 보낸다.     
  
이 때. TID(transactional.id)가 설정된 경우에는 InitPidRequest와 함께 TID가 트랜잭션 코디네이터에게 전송된다.        
트랜잭션 코디네이터는 TID, PID를 매핑하고 해당 정보를 트랜잭션 로그에 기록한다.      
그런 다음 PID 에포크를 한단계 올리는 동작을 하게 되고,      
PID 에포크가 올라감에 따라 이전의 동일한 PID와 이전 에포크에 대한 쓰기 요청을 무시된다.      
에프코를 활용하는 이유는 신뢰성 있는 메시지 전송을 하기 위함이다.   

[#](#)  
   
그 다음으로는 트랜잭션 시작 동작입니다.          
프로듀선느 beginTransaction() 메서드를 이용해 새로운 트랜잭션의 시작을 알리게 된다.       
프로듀서는 내부적으로 트랜잭션이 시작됐음을 기록하지만,       
트랜잭션 코디네이터 관점에서는 첫번째 레코드가 전송될 때까지 트랜잭션이 시작된 것 아니다.     

[#](#)   
 
다음으로 트랜잭션 상태 추가 동작입니다.      
트랜잭션 코디네이터는 전체 트랜잭션을 관리한다.  
      
그리고 각 트랜잭션 상태의 내용을 기록하는 일도 매우 중요하다.      
프로듀서는 토픽 파티션 정보를 트랜잭션 코디네이터에 전달하고,    
트랜잭션 코디네이터는 해당 정보를 트랜잭션 로그에 기록한다.     

TID와 P0(파티션0)의 정보가 트랜잭션 로그에 기록되며, 트랜잭션의 현재 상태를  Ongoing 으로 표시한다.          
만약 트랜잭션 로그에 추가되는 첫번째 파티션이라면, 트랜잭션 코디네이터는 해당 트랜잭션에 대한 타이머를 시작합니다.    
기본값으로 1분 동안 트랜잭션 상태에 대한 업데이트가 없다면, 해당 트랜잭션은 실패로 처리된다.      
   
[#](#)  
 
다음은 메시지 전송 동작이다.       
이 단계에서 프로듀서는 대상 토픽의 파티션으로 메시지를 전송한다.    
 
P0(파티션0)으로 메시지를 전송했고, 해당 메시지에는 PID, 에포크, 시퀀스 번호가 함께 포함되어 전송된다.      
브로커가 2개 있는 이유는 트랜잭션 코디네이터가 있는 브로커와 프로듀서가 전송하는 메시지를 받는 브로커가 서로 다르기 때문이다.   

[#](#)   
 
그 다음으로는 트랜잭션 종료 요청 동작입니다.       
메시지 전송을 완료한 프로듀서는 `commit Transaction()` 메서드 또는    
`abortTransaction()` 메서드 중 하나를 반드시 호출해야하며          
해당 메서드의 호출을 통해 트랜잭션이 완료됨을 트랜잭션 코디네이터에게 알린다.     
  
트랜잭션 코디네이터는 두 단계의 커밋 과정을 시작하게 되며,     
첫번째 단계로 트랜잭션 로그에 해당 트랜잭션에 대한 PrepareCommit 또는 PrepareAborpt를 기록한다.    

[#](#)   

다음은 사용자 토픽에 표시하는 단계이다.      
트랜잭션 코디네이터는 두 번재 단계로서 트랜잭션 로그에 기록된 토픽의 파티션에 트랜잭션 커밋 표시를 기록한다.     
여기서 기록하는 메시지가 바로 컨트롤 메시지다.      

예를 들어, 트랜잭션 프로듀서가 파티션0에 메시지를 전송했고 해당 메시지의 오프셋이 1이라고 가정해본다.     
트랜잭션 코디네이터는 파티션0에 트랜잭션 커밋 표시 메시지를 기록하고,       
이 추가 메시지(컨트롤 메시지)로 인해 파티션0의 마지막 오프셋은 2로 증가한다.   

메시지는 해당 PID의 메시지가 제대로 전송됐는지 여부를 컨슈머에게 나타내는 용도로도 사용된다.       
따라서 트랜잭션이 커밋이 끝나지 않은 메시지는 컨슈머에게 반환하지 않는 오프셋의 순서 보장을 위해         
트랜잭션 성공 또는 실패를 나타내는 ISO라는 오프셋을 유지하게 된다.        
이 내용은 잠시 후 정확히 한 번 전송 예정 실습 과정에서 다시 한번 확인해본다.   

[#](#)   
 
이제 마지막 단계인 트랜잭션 완료이다.        
트랜잭션 코디네이터는 완료됨이라고 트랜잭션 로그에 기록한다.       
그리고 프로듀서에게 해당 트랜잭션이 완료됨을 알린 다음 해당 트랜잭션에 대한 처리는 모두 마무리 된다.      
트랜잭션을 이용하는 컨슈머는 read_committed 설정을 하면 트랜잭션에 성공한 메시지들만 읽을 수 있게 된다.     

















