# 카프카 보안의 세가지 요소  
    
기본적으로 카프카는 최초 설치 과정에서 보안이 설정되지 않으므로          
어떤 클라이언트든지 **카프카와 동일한 네트워크에 위치하거나 카프카와 통신만 가능하다면 자유롭게 카프카와 연결할 수 있다.**           
즉, **보안을 설정하지 않으면 사용자 입장에서는 악의적인 사용자로 인해 손쉽게 주요 정보가 유출될 위험에 놓일 수 있다.**      
     
또 권한과 관련된 부분도 문제가 될 수 있다.    
카프카와 연결 가능한 클라이언트들은 권한을 갖고 있으므로 토픽에 메시지를 전송하고 가져올 수 있는 것이다.       
여기서, **본의아닌 실수로 다른 토픽에 메시지를 보낸다던가 하는 상황이 발생할 수 있으며 데이터의 정합성을 깨뜨릴 수 있다.**      
 
그리고 가장 큰 취약점이 하나 있는데, 바로 **클라이언트와 카프카 간의 통신이 암호화되어 있지 않기 때문에**      
악의적인 목적을 가진 사용자가 **클라이언트와 카프카 사이의 통신에 끼어들어 모든 패킷을 가로챌 수 있고, 중요 데이터가 노출될 수 있다.**     

카프카에서는 앞서 말한 취약점들을 보안하기 위해 3가지 요소가 필요하다.   

* **암호화**     
    * 악의적인 목적으로 통신하는 데이터를 가로채면, 높은 수준의 보안을 적용한 의미가 없어진다.    
    * 따라서 악의적인 목적을 가진 사용자가 중간에서 패킷을 가로채더라도 암호화를 설정해두어 데이터를 읽을 수 없게 해야한다.   
    * https로 접근하는 것과 비슷하다고 보면된다.  
* **인증**    
    * 카프카 클라이언트들 중에서, 안전하고 확인된 클라이언트만 접근할 수 있도록 설정하는 것이다.   
    * 아이디/비밀번호와 같은 인증 정보를 통해 특정 클라이언트만 접근하도록 하는 것과 비슷하다.    
* **권한**   
    * 인증받은 클라이언트들이 모든 권한을 갖게되면 실수가 발생하기 쉽다.  
    * 특정 클라이언트가 특정 토픽에 데이터를 전송할 수 있어야한다.     

카프카애서는 `암호화`/`인증`/`권한` 이 3가지 요소를 모두 충족해야 비로소 완벽한 보안을 갖출 수 있다.  

## 암호화(SSL)    

카프카와 클라이언트간의 통신에는 암호화를 적용해야한다.      
이러한 암호화 통신을 설정하기 위해 일반적으로 SSL을 사용한다.  

SSL은 보안 소켓 레이어의 약자로, 노드간의 통신 보안을 적용하기 위한표준 암호 규약이다.   
웹에서는 이러한 프로토콜을 이용해서 http 통신 대신, https 통신을 진행한다.   

### SSL 동작   
SSL은 인증기관으로부터 인증서를 발급받은 후,       
인증서를 이용한 퍼블릭 키/프라이빗 키 방식으로 서버와 클라이언트가 암호화 복호화를 하면서 통신한다.       

암호화를 위해 서버와 클라이언트는 미리 지정된 키를 주고 받아야하는데   
이때 사용하는 키의 방식으로 대칭키 방식과 비대칭키 방식이 있다.    

대칭키 방식은 하나의 키를 이용해 암/복호화를 하는 것이고      
비대칭키 방식은 서로 다른 키를 이용해 암/복호화를 하는 것이다.   

대칭키 방식은 오버헤드가 적은 반면 노출 위험성이 있고, 비대칭키 방식은 키의 노출 위험성은 적지만 오버헤드가 크다.      
SSL 보안을 강화하면서 효율적인 고성능을 얻기 위해 대칭 키와 비대칭 키의 2가지 방식을 모두 혼용하는 방식으로 사용한다.   
그에 따라 SSL 통신 방식은 다소 복잡해지지만, 나름대로 높은 성능을 갖기 위해 최적화되어 있다고 볼 수 있다.   

## 인증(SASL)   
  
SASL 은 인터넷 프로토콜 인증과 데이터 보안을 위한 프레임워크로서 카프카에서도 사용된다.    
애플리케이션 프로토콜에서 인증 매커니즘을 분리함으로써 모든 애플리케이션에서 사용할 수 있다.    
SASL 메커니즘으로는 SCRAM, GSSAPI, OPLAIN, AUTHBEARE, DIGEST-MD5 등이 있으며, 
카프카에서는 다음과 같은 4가지 매커니즘을 지원한다.    

**SASL/GSSAPI**     
* 카프카 0.9 버전부터 지원되었다.       
* GSSAPI 는 커버로스 인증 방식으로 많이 사용되는 인증 방식 중 하나이다.      
* 회사 내부에 별도의 커버로스 서버가 있는 환경이라면 커버로스 인증 방식을 사용하는 것이 가장 좋다.     
* 커버로스 인증 방식을 적용할 때는 **렐름(REALM)이라는 설정이 필요한데**,   
  이 때는 되도록 하나의 렐름으로 모든 애플리케이션을 적용하는 방법을 추천한다.      
  크로스 렐름 설정으로 인해 클라이언트들의 재인증, 인증 실패 등이 일어나는 경우가 종종 있기 때문이다.      
* [구축 방법](https://blogger.pe.kr/920)은 해당 블로그를 통해 참고하자  
  
**SASL/PLAIN**    
* 0.10.0 버전부터 지원되었다.  
* PLAIN은 아이디와 비밀번호를 텍스트 형태로 사용하는 방법으로서,   
* 운영환경보다는 개발 환경에서 테스트 등의 목적으로 활용한다.  

**SASL/SCRAM-SHA-256 또는 SASL/SCRAM-SHA-512**   
* 0.10.2 버전부터 지원되었다.    
* 본래의 암호에 해시된 내용을 추가함으로써 암호가 유출되어도 본래 암호를 알 수 없어 안전하게 저장할 수 있다.  
* 이러한 의미로 솔티드 챌린지 응답 인증 매커니즘이라는 이름이 붙고 이에 약어인 SCRAM은   
  인증 정보를 주키퍼에 저장해 사용하는 방식으로서,  
  토큰 방식도 지원하므로 별도의 커버로스 서버가 구성되어 있지 않은 환경에서 카프카의 인증을 구성해야할 때 가장 좋다.  

**SASL/OAUTHBEARER**         
* 2.0 버전부터 지원되었다.  
* OAUTH 최근 인증에서 많이 사용되는 방식이다.   
* 하지만, 카프카에서 제공하는 기능은 매우 제한적이라 개발 환경 정도에만 적용가능한 수준이다.  
* 운영 환경에서 사용하기 위해 별도의 핸들러를 구성해야하는 불편함이 있다.   

## 권한
  
방화벽등에서 권한을 설정하는 대표적인 방법은 ACL을 적용하는 것이다.     
ACL은 접근 제어 리스트의 약자로서 규칙 기반의 리스트를 만들어 접근 제어를 하는 것이다.      
         
관리자가 카프카를 사용하는 모든 사용자에게 동일한 권한을 부여하는 것에는 장단점이 있다.          
우선 손쉽게 자신이 원하는 데이터를 기져길 수 있으므로 **불필요한 커뮤니케이션 비용이 들지 않는다는 장점이 있다.**      
이는 바로 카프카를 사용하는 장점 중 하나인 것 같다.     

[#](#)  
        
A 서비스 부서에서 사용하는 토픽은 A 이다.           
하지만, B 서비스에서 개발 담당자의 **실수 또는 커뮤니케이션 오류** 등으로 인해 A 토픽으로 B 서비스의 메시지들을 전송한다.           
이후, A 서비스에서는 메시지를 구독하다가 파싱에러가 발생하면서 예끼치 않게 종료되거나 정합성에 문제가 생길 수 있다.     
이러한 문제를 각 사용자별로 올바른 권한을 할당한다면 이러한 이슈들은 발생하지 않을 것이다.   
 
카프카에서 이런 권한 설정을 위해 ACL 기능을 제공한다.     
간단히 CLI로 ACL을 추가하거나 삭제할 수 있으며 모든 ACL 은 주키퍼에 저장한다.      
ACL은 리소스 타입별로 구체적인 설정이 가능하다.    
   
리소스 타입은 크게 토픽, 그룹, 클러스터, 트랜잭셔널 ID, 위입 토큰으로 나뉜다.    

```
카프카에 제공하는 ACL은 매우 강력하면 방화벽 같은 장비가 업어도 상세한 권한 설정이 가능하다.   
이책에서 미쳐 설명하지 못한 상세한 권한 관련 내용은 다음 아파치 카프카 공식 문서에서 확인할 수 있다.  

컨플루언트에서 제공하는 다음 문서는 표로 정리되어 있어 좀 더 보기가 편하다.   
```
