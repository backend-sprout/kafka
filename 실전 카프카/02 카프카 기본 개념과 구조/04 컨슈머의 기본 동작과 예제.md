# 컨슈머의 기본 동작과 예제 
 
컨슈머는 토픽에 저장되어 있는 메시지를 가져오는 역할을 담당한다.       
컨슈머가 단순하게 카프카로부터 메시지만 가져오는 것 같지만,         
내부적으로는 컨슈머 그룹, 리밸런싱 등 여러 동작을 수행한다.      
      
이러한 컨슈머의 기본 동작과 옵션을 잘 이해한다면 내가 원하는 형태로 컨슈머를 구성, 운영할 수 있다.        
프로듀서로 아무리 빠르게 메시지를 전송하더라도 컨슈머가 카프카로부터 빠르게 메시지를 읽어오지 못한다면 결국 지연이 발생한다.       

# 컨슈머의 기본 동작   
컨슈머 그룹은 하나 이상의 컨슈머들이 모여있는 그룹을 의미하고 컨슈머는 반드시 컨슈머 그룹에 속해야한다.         
**컨슈머 그룹은 각 파티션의 리더에게 카프카 토픽에 저장된 메시지를 가져오기 위한 요청을 보낸다.**       
     
이때, 파티션 수와 컨슈머 수는 1대1로 매핑되는 것이 가장 이상적이다.    
컨슈머 수가 파티션 수보다 많다고 해서 토픽의 메시지를 더 빠르게 가져오거나 처리량이 높아지는 것은 아니다.        
오히려 많은 수의 컨슈머들이 그냥 대기 상태로 존재하게 되는 문제가 발생한다.    
      
액티브/스탠바이 개념으로 추가 컨슈머가 더 있으면 좋을 것이라고 생각할 수도 있지만,    
**컨슈머 그룹내에서 리밸런싱 동작을 통해 장애가 발생한 컨슈머의 역할을 동일한 그룹에 있는 다른 컨슈머가 그 역할을 대신 수행하므로**         
굳이 장애 대비를 위한 추가 컨슈머 리소스를 할당하지 않아도 된다.          
(즉, 장애 발생시 다른 컨슈머가 여러 파티션에 대해서 작업을 처리해줄 수 있다.)   

# 컨슈머의 주요 옵션  

카프카에는 메시지가 잘 저장되어 있어도   
관리자가 컨슈머를 어떻게 처리하고 다루느냐에 따라    
컨슈머 동작에서 메시지의 중복, 유실등 여러가지 상황이 발생할 수 있다.    

컨슈머를 사용하는 목적이 최대한 안정적이며 지연이 없도록 카프카로부터 메시지를 가져오는 것인데,   
이를 위한 옵션을 잘이해하고 사용해야만 자신이 원하는 형태로 컨슈머가 동작할 것이다.  
컨슈머는 옵션에 따라 오토 커밋, 배치 등의 설정을 할 수 있다.  

|컨슈머 옵션|설명|
|--------|---|
|bootstrap.servers|프로듀서와 동일하게 브로커의 정보를 입력한다|   
|fetch.min.bytes|한번에 가져올 수 있는 최소 데이터크기다.<br>만약 지정한 크기보다 작은 경우, 요청에 응답하지 않고 데이터가 누적될때까지 기다린다.|   
|group.id|컨슈머가 속한 커슈머 그룹을 식별하는 식별자다.<br>동일한 그룹내의 컨슈머 정보는 모두 공유된다.|   
|heartbeat.interval.ms|하트비트가 있다는 것은 컨슈머의 상태가 active임을 의미한다.<br>session.timeout.ms와 밀접한 관계가 있으며,<br>session.timeout.ms보다 낮은값으로 설정해야한다.<br>일반적으로 session.timeout.ms의 1/3 크기로 해야한다.|
|max.partition.fetch.bytes|파티션당 가져올 수 있는 최대 크기를 의미한다.|   
|session.timeout.ms|이 시간을 이용해, 컨슈머가 종료된 것인지 판단한다.<br>컨슈머는 주기적으로 하트비트를 보내야하고,<br>만약 이 시간전까지 하트비트를 보내지 않았다면 해당 컨슈머는 종료된 것으로 간주하고<br>컨슈머 그룹에서 제외하고 리밸런싱을 시작한다|
|enable.auto.commit|백그라운드로 주기적으로 오프셋을 커밋한다.|
|auto.offset.reset|카프카에서 초기 오프셋이 없거나<br>현재 오프셋이 더이상 조재하지 않는 경우에 다음 옵션으로 reset한다.<br>* earliest: 가장 초기의 오프셋값으로 설정한다.<br>* latest: 가장 마지막의 오프셋값으로 설정한다.<br>* none: 이전 오프셋값을 찾지 못하면 에러를 나타낸다.|
|fetch.max.bytes|한 번의 가져오기 요청으로 가져올 수 있는 최대 크기다.|
|group.instance.id|컨슈머의 고유한 식별자이다.<br>만약 설정한다면 static 멤버로 간주되어, 불필요한 리밸린성을 하지 않는다.|   
|isolation.level|트랜잭션 컨슈머에서 사용되는 옵션으로,<br>read_uncommitted는 기본값으로 모든 메시지를 읽고,<br>read_committed는 트랜잭션이 완료된 메시지만 읽는다.|  
|max.poll.records|한번의 `poll()` 요청으롷 가져오는 최대 메시지 수이다.|   
|partitions.assignment.strategy|파티션 할당 전략이며, 기본값은 range이다.|    
|fetch.max.wait.ms|fetch.min.bytes에 의해 설정된 데이터보다 적은 경우 요청에 대한 응답을 기다리는 최대 시간이다.|    

# 컨슈머 예제 


      








